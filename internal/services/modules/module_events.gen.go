// Code generated by "module_events"; DO NOT EDIT.
// See events.go

package modules

import (
	"log/slog"
	"reflect"

	"github.com/bwmarrin/discordgo"
)

// RegisterEventHandlers registers event handlers for all modules.
//
// When registering event handlers, create a wrapper function that first checks if the module is enabled for the guild.
// If the module is not enabled, the event handler should return immediately.
func (m *ModuleManager) RegisterEventHandlers() {
	for _, module := range m.modules {
		for _, handler := range module.EventHandlers() {
			t := reflect.TypeOf(handler)
			if t.Kind() != reflect.Func {
				slog.Error("Event handler is not a function.", slog.String("module_id", module.ID()))
				continue
			}

			argNum := t.NumIn()
			if argNum != 2 {
				slog.Error("Event handler has invalid argument count.", slog.String("module_id", module.ID()))
				continue
			}

			eventArg := t.In(1)
			if false {
			} else if eventArg == reflect.TypeOf((*discordgo.Ready)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.Ready) {
					guildID := e.Application.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "Ready"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "Ready"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ChannelCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ChannelCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ChannelCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ChannelCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ChannelUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ChannelUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ChannelUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ChannelUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ChannelDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ChannelDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ChannelDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ChannelDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ChannelPinsUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ChannelPinsUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ChannelPinsUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ChannelPinsUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ThreadCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ThreadCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ThreadCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ThreadCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ThreadUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ThreadUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ThreadUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ThreadUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ThreadDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ThreadDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ThreadDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ThreadDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ThreadListSync)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ThreadListSync) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ThreadListSync"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ThreadListSync"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ThreadMemberUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ThreadMemberUpdate) {
					guildID := e.Member.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ThreadMemberUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ThreadMemberUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ThreadMembersUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ThreadMembersUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ThreadMembersUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ThreadMembersUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildBanAdd)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildBanAdd) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildBanAdd"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildBanAdd"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildBanRemove)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildBanRemove) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildBanRemove"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildBanRemove"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildMemberAdd)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildMemberAdd) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildMemberAdd"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildMemberAdd"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildMemberUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildMemberUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildMemberUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildMemberUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildMemberRemove)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildMemberRemove) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildMemberRemove"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildMemberRemove"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildRoleCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildRoleCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildRoleCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildRoleCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildRoleUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildRoleUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildRoleUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildRoleUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildRoleDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildRoleDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildRoleDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildRoleDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildEmojisUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildEmojisUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildEmojisUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildEmojisUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildMembersChunk)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildMembersChunk) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildMembersChunk"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildMembersChunk"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildIntegrationsUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildIntegrationsUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildIntegrationsUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildIntegrationsUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.StageInstanceEventCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.StageInstanceEventCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "StageInstanceEventCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "StageInstanceEventCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.StageInstanceEventUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.StageInstanceEventUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "StageInstanceEventUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "StageInstanceEventUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.StageInstanceEventDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.StageInstanceEventDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "StageInstanceEventDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "StageInstanceEventDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildScheduledEventCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildScheduledEventCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildScheduledEventCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildScheduledEventCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildScheduledEventUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildScheduledEventUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildScheduledEventUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildScheduledEventUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildScheduledEventDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildScheduledEventDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildScheduledEventDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildScheduledEventDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildScheduledEventUserAdd)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildScheduledEventUserAdd) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildScheduledEventUserAdd"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildScheduledEventUserAdd"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.GuildScheduledEventUserRemove)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.GuildScheduledEventUserRemove) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "GuildScheduledEventUserRemove"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "GuildScheduledEventUserRemove"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageReactionAdd)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageReactionAdd) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageReactionAdd"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageReactionAdd"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageReactionRemove)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageReactionRemove) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageReactionRemove"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageReactionRemove"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageReactionRemoveAll)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageReactionRemoveAll) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageReactionRemoveAll"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageReactionRemoveAll"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.PresenceUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.PresenceUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "PresenceUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "PresenceUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.TypingStart)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.TypingStart) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "TypingStart"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "TypingStart"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.VoiceServerUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.VoiceServerUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "VoiceServerUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "VoiceServerUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.VoiceStateUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.VoiceStateUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "VoiceStateUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "VoiceStateUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.MessageDeleteBulk)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.MessageDeleteBulk) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "MessageDeleteBulk"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "MessageDeleteBulk"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.WebhooksUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.WebhooksUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "WebhooksUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "WebhooksUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.InteractionCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.InteractionCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "InteractionCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "InteractionCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.InviteCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.InviteCreate) {
					guildID := e.Channel.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "InviteCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "InviteCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.InviteDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.InviteDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "InviteDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "InviteDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.ApplicationCommandPermissionsUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.ApplicationCommandPermissionsUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "ApplicationCommandPermissionsUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "ApplicationCommandPermissionsUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.AutoModerationRuleCreate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.AutoModerationRuleCreate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "AutoModerationRuleCreate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "AutoModerationRuleCreate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.AutoModerationRuleUpdate)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.AutoModerationRuleUpdate) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "AutoModerationRuleUpdate"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "AutoModerationRuleUpdate"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.AutoModerationRuleDelete)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.AutoModerationRuleDelete) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "AutoModerationRuleDelete"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "AutoModerationRuleDelete"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			} else if eventArg == reflect.TypeOf((*discordgo.AutoModerationActionExecution)(nil)) {
				wrappedHandler := func(session *discordgo.Session, e *discordgo.AutoModerationActionExecution) {
					guildID := e.GuildID
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "AutoModerationActionExecution"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "AutoModerationActionExecution"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			}

			slog.Info("Registered event handlers.", slog.String("module_id", module.ID()))
		}
	}
}
