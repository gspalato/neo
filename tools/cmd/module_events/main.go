// This codegen tool generates module event handler code with support for all discordgo events.
// It is called with `go generate` on the file internal/services/modules/modules.go.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

const tmpl = `
// Code generated by "module_events"; DO NOT EDIT.
// See events.go

package modules

import (
	"reflect"
	"log/slog"

	"github.com/bwmarrin/discordgo"
)

// RegisterEventHandlers registers event handlers for all modules.
//
// When registering event handlers, create a wrapper function that first checks if the module is enabled for the guild.
// If the module is not enabled, the event handler should return immediately.
func (m *ModuleManager) RegisterEventHandlers() {
	for _, module := range m.modules {
		for _, handler := range module.EventHandlers() {
			t := reflect.TypeOf(handler)
			if t.Kind() != reflect.Func {
				slog.Error("Event handler is not a function.", slog.String("module_id", module.ID()))
				continue
			}

			argNum := t.NumIn()
			if argNum != 2 {
				slog.Error("Event handler has invalid argument count.", slog.String("module_id", module.ID()))
				continue
			}

			eventArg := t.In(1)
			if false {}
			{{ range . }}
			else if eventArg == reflect.TypeOf((*discordgo.{{ .Name }})(nil)) {
				wrappedHandler := func (session *discordgo.Session, e *discordgo.{{ .Name }}) {
					guildID := e.{{ .PartialGuildIDFieldPath }}
					isEnabled := m.IsModuleEnabled(guildID, module.ID()) || m.IsModuleEnabled("", module.ID())

					if !isEnabled {
						slog.Info("Module not enabled for guild. Not executing handler.",
							slog.String("module_id", module.ID()), slog.String("guild_id", guildID), slog.String("event", "{{ .Name }}"))
						return
					} else {
						slog.Info("Executing event handler.", slog.String("module_id", module.ID()), slog.String("event", "{{ .Name }}"))
					}

					reflect.ValueOf(handler).Call([]reflect.Value{
						reflect.ValueOf(session),
						reflect.ValueOf(e),
					})
				}

				m.session.AddHandler(wrappedHandler)
			}
			{{ end }}

			slog.Info("Registered event handlers.", slog.String("module_id", module.ID()))
		}
	}
}
`

type TmplInfo struct {
	Name                    string
	PartialGuildIDFieldPath string
}

func main() {
	var buf bytes.Buffer
	dir := filepath.Dir(".")

	// Find events.go file in discordgo source code
	gopath := os.Getenv("GOPATH")
	if gopath == "" {
		log.Fatal("GOPATH not set")
	}
	log.Printf("Found GOPATH: %s\n", gopath)

	// Get discordgo package folder.
	var discordgoFolderName string
	discordgoParentPath := filepath.Join(gopath, "pkg", "mod", "github.com", "bwmarrin")
	entries, err := os.ReadDir(discordgoParentPath)
	if err != nil {
		log.Fatalf("reading directory: %s", err)
	}

	for _, entry := range entries {
		if entry.IsDir() && strings.HasPrefix(entry.Name(), "discordgo") {
			discordgoFolderName = entry.Name()
			break
		}
	}

	discordgoPath := filepath.Join(discordgoParentPath, discordgoFolderName)

	// Parse all files in the discordgo package into typeInfo.
	var typeInfo map[string]*ast.StructType
	err = filepath.Walk(discordgoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		fs := token.NewFileSet()
		parsedFile, err := parser.ParseFile(fs, path, nil, 0)
		if err != nil {
			log.Fatalf("warning: internal error: could not parse file while parsing discordgo type info: %s", err)
			return err
		}

		if typeInfo == nil {
			typeInfo = buildTypeInfo(parsedFile)
		} else {
			for k, v := range buildTypeInfo(parsedFile) {
				typeInfo[k] = v
			}
		}

		return nil
	})

	if err != nil {
		log.Fatalf("error walking and parsing discordgo package: %s", err)
	}

	// Get events.go path.
	eventsFilePath := filepath.Join(discordgoPath, "events.go")
	log.Printf("Found events.go path: %s\n", eventsFilePath)

	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, eventsFilePath, nil, 0)
	if err != nil {
		log.Fatalf("warning: internal error: could not parse events.go: %s", err)
		return
	}

	var infos []TmplInfo

	// Use the Inspect function to walk AST looking for struct type nodes.
	// And then find the guild ID field in the struct type.
	ast.Inspect(parsedFile, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if _, isStruct := ts.Type.(*ast.StructType); isStruct {
				structName := ts.Name.Name

				// Recursively walk the struct type to find the guild ID variable
				found, guildIDField := findGuildIDField(ts, typeInfo)
				if !found {
					fmt.Printf("warning: could not find guild ID for event struct %s\n", structName)
					return true
				}

				infos = append(infos, TmplInfo{
					Name:                    structName,
					PartialGuildIDFieldPath: guildIDField,
				})
			}
		}
		return true
	})

	var eventHandlerTmpl = template.Must(template.New("module_events").Parse(tmpl))
	eventHandlerTmpl.Execute(&buf, infos)

	// Fix the output's if/else formatting (remove spaces and newlines)
	ifelseRegex := regexp.MustCompile(`}\s*\n*else`)
	src, err := format.Source([]byte(ifelseRegex.ReplaceAllString(buf.String(), "} else")))
	if err != nil {
		log.Println("warning: internal error: invalid Go generated:", err)
	}

	err = os.WriteFile(filepath.Join(dir, strings.ToLower("module_events.gen.go")), src, 0644)
	if err != nil {
		log.Fatal(buf, "error writing output: %s", err)
	}
}

// findGuildIDField finds the guild event's ID field in a struct type node by recursively walking the AST.
func findGuildIDField(node ast.Node, typeInfo map[string]*ast.StructType) (bool, string) {
	var result string

	var checkStruct func(st *ast.StructType, path string) bool
	checkStruct = func(st *ast.StructType, path string) bool {
		if st == nil {
			return false
		}

		for _, field := range st.Fields.List {
			var fieldName string
			if len(field.Names) > 0 {
				fieldName = field.Names[0].Name
			}

			currentPath := path
			if fieldName != "" {
				if currentPath != "" {
					currentPath += "."
				}
				currentPath += fieldName
			}

			fmt.Printf("Checking field: %s\n", currentPath) // Debug print

			if fieldName == "GuildID" {
				result = currentPath
				fmt.Printf("Found GuildID at: %s\n", result) // Debug print
				return true
			}

			if fieldName == "Guild" {
				if structType, ok := field.Type.(*ast.StructType); ok {
					for _, subField := range structType.Fields.List {
						if len(subField.Names) > 0 && subField.Names[0].Name == "ID" {
							result = currentPath + ".ID"
							fmt.Printf("Found Guild.ID at: %s\n", result) // Debug print
							return true
						}
					}
				}
			}

			switch t := field.Type.(type) {
			case *ast.StructType:
				if checkStruct(t, currentPath) {
					return true
				}
			case *ast.Ident:
				if embedded, ok := typeInfo[t.Name]; ok {
					if checkStruct(embedded, currentPath) {
						return true
					}
				}
			case *ast.StarExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					if embedded, ok := typeInfo[ident.Name]; ok {
						if checkStruct(embedded, currentPath) {
							return true
						}
					}
				}
			case *ast.SelectorExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					if strings.ToLower(ident.Name) == "guild" && t.Sel.Name == "ID" {
						result = currentPath
						fmt.Printf("Found Guild.ID (from another package) at: %s\n", result) // Debug print
						return true
					}
				}
			}
		}
		return false
	}

	found := false

	switch n := node.(type) {
	case *ast.File:
		ast.Inspect(n, func(n ast.Node) bool {
			if structType, ok := n.(*ast.StructType); ok {
				fmt.Println("Inspecting a new struct in file") // Debug print
				if checkStruct(structType, "") {
					found = true
					return false
				}
			}
			return true
		})
	case *ast.TypeSpec:
		if structType, ok := n.Type.(*ast.StructType); ok {
			fmt.Println("Inspecting TypeSpec struct") // Debug print
			found = checkStruct(structType, "")
		}
	default:
		fmt.Printf("Unsupported node type: %T\n", node)
	}

	return found, result
}

// Helper function to build a map of all struct types in a file
func buildTypeInfo(file *ast.File) map[string]*ast.StructType {
	typeInfo := make(map[string]*ast.StructType)
	ast.Inspect(file, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				typeInfo[typeSpec.Name.Name] = structType
			}
		}
		return true
	})
	return typeInfo
}
